diff -ur --new-file linux-2.2.15-pre13.virgin/arch/alpha/defconfig linux/arch/alpha/defconfig
--- linux-2.2.15-pre13.virgin/arch/alpha/defconfig	Tue Jan  4 11:12:10 2000
+++ linux/arch/alpha/defconfig	Tue Mar  7 19:57:29 2000
@@ -239,6 +239,9 @@
 # CONFIG_SERIAL_CONSOLE is not set
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 CONFIG_MOUSE=y
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/arm/defconfig linux/arch/arm/defconfig
--- linux-2.2.15-pre13.virgin/arch/arm/defconfig	Thu Feb 25 11:46:46 1999
+++ linux/arch/arm/defconfig	Tue Mar  7 20:01:46 2000
@@ -156,6 +156,10 @@
 CONFIG_SCSI_PPA=m
 CONFIG_SCSI_PPA_HAVE_PEDANTIC=2
 
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
+
 #
 # Network device support
 #
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/i386/defconfig linux/arch/i386/defconfig
--- linux-2.2.15-pre13.virgin/arch/i386/defconfig	Tue Mar  7 19:46:57 2000
+++ linux/arch/i386/defconfig	Tue Mar  7 19:57:40 2000
@@ -300,6 +300,9 @@
 # CONFIG_SERIAL_CONSOLE is not set
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 CONFIG_MOUSE=y
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/i386/kernel/Makefile linux/arch/i386/kernel/Makefile
--- linux-2.2.15-pre13.virgin/arch/i386/kernel/Makefile	Wed Jan 20 11:18:53 1999
+++ linux/arch/i386/kernel/Makefile	Tue Mar  7 19:52:45 2000
@@ -14,8 +14,8 @@
 
 O_TARGET := kernel.o
 O_OBJS   := process.o signal.o entry.o traps.o irq.o vm86.o \
-            ptrace.o ioport.o ldt.o setup.o time.o sys_i386.o
-OX_OBJS  := i386_ksyms.o
+            ptrace.o ioport.o ldt.o time.o sys_i386.o
+OX_OBJS  := i386_ksyms.o setup.o
 MX_OBJS  :=
 
 ifdef CONFIG_PCI
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/m68k/defconfig linux/arch/m68k/defconfig
--- linux-2.2.15-pre13.virgin/arch/m68k/defconfig	Thu Feb 25 11:46:46 1999
+++ linux/arch/m68k/defconfig	Tue Mar  7 19:58:10 2000
@@ -223,6 +223,9 @@
 CONFIG_AMIGAMOUSE=y
 CONFIG_ATARIMOUSE=y
 CONFIG_AMIGA_BUILTIN_SERIAL=y
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
 # CONFIG_GVPIOEXT is not set
 # CONFIG_GVPIOEXT_LP is not set
 # CONFIG_GVPIOEXT_PLIP is not set
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/mips/defconfig linux/arch/mips/defconfig
--- linux-2.2.15-pre13.virgin/arch/mips/defconfig	Mon Aug  9 13:04:38 1999
+++ linux/arch/mips/defconfig	Tue Mar  7 19:58:30 2000
@@ -252,6 +252,9 @@
 CONFIG_SERIAL=m
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
 # CONFIG_UNIX98_PTYS is not set
 # CONFIG_MOUSE is not set
 # CONFIG_QIC02_TAPE is not set
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/ppc/apus_defconfig linux/arch/ppc/apus_defconfig
--- linux-2.2.15-pre13.virgin/arch/ppc/apus_defconfig	Thu Feb 25 11:46:47 1999
+++ linux/arch/ppc/apus_defconfig	Tue Mar  7 19:59:14 2000
@@ -303,6 +303,9 @@
 CONFIG_SERIAL=m
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_MOUSE is not set
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/ppc/chrp_defconfig linux/arch/ppc/chrp_defconfig
--- linux-2.2.15-pre13.virgin/arch/ppc/chrp_defconfig	Thu Feb 25 11:46:47 1999
+++ linux/arch/ppc/chrp_defconfig	Tue Mar  7 19:58:57 2000
@@ -261,6 +261,9 @@
 # CONFIG_SERIAL_CONSOLE is not set
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
 # CONFIG_UNIX98_PTYS is not set
 # CONFIG_MOUSE is not set
 # CONFIG_UMISC is not set
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/ppc/common_defconfig linux/arch/ppc/common_defconfig
--- linux-2.2.15-pre13.virgin/arch/ppc/common_defconfig	Tue Jan  4 11:12:12 2000
+++ linux/arch/ppc/common_defconfig	Tue Mar  7 19:59:35 2000
@@ -337,6 +337,9 @@
 CONFIG_SERIAL=m
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 CONFIG_MOUSE=y
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/ppc/defconfig linux/arch/ppc/defconfig
--- linux-2.2.15-pre13.virgin/arch/ppc/defconfig	Tue Jan  4 11:12:12 2000
+++ linux/arch/ppc/defconfig	Tue Mar  7 19:58:43 2000
@@ -337,6 +337,9 @@
 CONFIG_SERIAL=m
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 CONFIG_MOUSE=y
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/ppc/gemini_defconfig linux/arch/ppc/gemini_defconfig
--- linux-2.2.15-pre13.virgin/arch/ppc/gemini_defconfig	Tue Jan  4 11:12:12 2000
+++ linux/arch/ppc/gemini_defconfig	Tue Mar  7 19:59:23 2000
@@ -285,6 +285,9 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_MOUSE is not set
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/ppc/mbx_defconfig linux/arch/ppc/mbx_defconfig
--- linux-2.2.15-pre13.virgin/arch/ppc/mbx_defconfig	Wed Mar 10 22:30:32 1999
+++ linux/arch/ppc/mbx_defconfig	Tue Mar  7 19:59:49 2000
@@ -192,6 +192,9 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
 # CONFIG_UNIX98_PTYS is not set
 # CONFIG_MOUSE is not set
 # CONFIG_QIC02_TAPE is not set
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/ppc/pmac_defconfig linux/arch/ppc/pmac_defconfig
--- linux-2.2.15-pre13.virgin/arch/ppc/pmac_defconfig	Tue Oct 26 18:53:39 1999
+++ linux/arch/ppc/pmac_defconfig	Tue Mar  7 19:59:59 2000
@@ -368,6 +368,9 @@
 # CONFIG_SERIAL is not set
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_PRINTER is not set
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/s390/defconfig linux/arch/s390/defconfig
--- linux-2.2.15-pre13.virgin/arch/s390/defconfig	Tue Mar  7 19:46:57 2000
+++ linux/arch/s390/defconfig	Tue Mar  7 20:02:36 2000
@@ -64,6 +64,9 @@
 CONFIG_3215_CONSOLE=y
 CONFIG_HWC=y
 CONFIG_HWC_CONSOLE=y
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
 
 #
 # Networking options
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/sparc/defconfig linux/arch/sparc/defconfig
--- linux-2.2.15-pre13.virgin/arch/sparc/defconfig	Tue Mar  7 19:46:57 2000
+++ linux/arch/sparc/defconfig	Tue Mar  7 20:01:00 2000
@@ -219,6 +219,10 @@
 CONFIG_SUNQE=m
 CONFIG_MYRI_SBUS=m
 
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
+
 #
 # Unix98 PTY support
 #
diff -ur --new-file linux-2.2.15-pre13.virgin/arch/sparc64/defconfig linux/arch/sparc64/defconfig
--- linux-2.2.15-pre13.virgin/arch/sparc64/defconfig	Tue Mar  7 19:46:57 2000
+++ linux/arch/sparc64/defconfig	Tue Mar  7 20:01:16 2000
@@ -262,6 +262,10 @@
 CONFIG_EEXPRESS_PRO100=m
 CONFIG_SK98LIN=m
 
+# CONFIG_DEVPS is not set
+# CONFIG_DEVMTAB is not set
+# CONFIG_DEVMODULES is not set
+
 #
 # Unix 98 PTY support
 #
diff -ur --new-file linux-2.2.15-pre13.virgin/drivers/char/Config.in linux/drivers/char/Config.in
--- linux-2.2.15-pre13.virgin/drivers/char/Config.in	Tue Mar  7 19:46:58 2000
+++ linux/drivers/char/Config.in	Tue Mar  7 19:52:45 2000
@@ -56,6 +56,9 @@
    dep_tristate 'Microgate SyncLink card support' CONFIG_SYNCLINK m
    dep_tristate 'HDLC line discipline support' CONFIG_N_HDLC m
 fi
+tristate 'Devps support' CONFIG_DEVPS
+tristate 'Devmounts support' CONFIG_DEVMTAB
+tristate 'Devmodules support' CONFIG_DEVMODULES
 bool 'Unix98 PTY support' CONFIG_UNIX98_PTYS
 if [ "$CONFIG_UNIX98_PTYS" = "y" ]; then
 	int 'Maximum number of Unix98 PTYs in use (0-2048)' CONFIG_UNIX98_PTY_COUNT 256
diff -ur --new-file linux-2.2.15-pre13.virgin/drivers/char/Makefile linux/drivers/char/Makefile
--- linux-2.2.15-pre13.virgin/drivers/char/Makefile	Tue Mar  7 19:46:58 2000
+++ linux/drivers/char/Makefile	Tue Mar  7 19:52:45 2000
@@ -620,6 +620,30 @@
   L_OBJS += dz.o
 endif
 
+ifeq ($(CONFIG_DEVPS),y)
+L_OBJS += devps.o
+else
+  ifeq ($(CONFIG_DEVPS),m)
+  M_OBJS += devps.o
+  endif
+endif
+
+ifeq ($(CONFIG_DEVMTAB),y)
+L_OBJS += devmtab.o
+else
+  ifeq ($(CONFIG_DEVMTAB),m)
+  M_OBJS += devmtab.o
+  endif
+endif
+
+ifeq ($(CONFIG_DEVMODULES),y)
+L_OBJS += devmodules.o
+else
+  ifeq ($(CONFIG_DEVMODULES),m)
+  M_OBJS += devmodules.o
+  endif
+endif
+
 include $(TOPDIR)/Rules.make
 
 fastdep:
diff -ur --new-file linux-2.2.15-pre13.virgin/drivers/char/devmodules.c linux/drivers/char/devmodules.c
--- linux-2.2.15-pre13.virgin/drivers/char/devmodules.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/devmodules.c	Tue Mar  7 22:37:42 2000
@@ -0,0 +1,270 @@
+/* vi: set sw=8 ts=8: */
+/*
+ * linux/drivers/char/devmodules.c
+ *
+ * Copyright (C) 2000 Erik Andersen <andersee@debian.org>
+ *
+ * May be copied or modified under the terms of the GNU General Public License.
+ * See linux/COPYING for more information.
+ *
+ * This driver implements an interface whereby programs such as lsmod(8) may
+ * obtain all the information they need to do their jobs.  Now you may ask,
+ * "Why not use /proc/modules?".  Thanks for asking.  Because /proc is big and
+ * bloated, and because using this driver we can avoid all that bloat and avoid
+ * having the kernel need to pretty print stuff and avoid having user-space
+ * then have to parse the stuff the kernel wasted its time formatting.
+ *
+ *
+ * Suggestions are welcome. Patches that work are more welcome though. ;-)
+ *
+ * When using this driver, running:
+ * 	mknod /dev/modules c 10 23
+ * could be considered helpful.
+ *
+ * ----------------------------------
+ * 1.00  Mar 07, 2000 -- Initial version.
+ *
+ *
+ *************************************************************************/
+
+#define DEVMODULES_VERSION "1.00"
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/malloc.h>
+#include <linux/miscdevice.h>
+#include <linux/devmodules.h>
+#include <linux/wrapper.h>
+#include <asm/pgtable.h>
+#include <asm/uaccess.h>
+
+
+/* Some variables used by this device */
+static struct wait_queue *devmodules_waitq = NULL;
+static int devmodules_already_opened = 0;
+static char *devmodulesfile = NULL;
+static int devmodules_ptr;
+static int devmodules_size;
+
+
+
+/****************************************************************************
+ * Handle opening and closing of the device
+ */
+
+static long long
+devmodules_lseek (struct file *file, long long offset, int orig)
+{
+	return -ESPIPE;
+}
+
+static ssize_t
+devmodules_read (struct file *file, char *buf, size_t count, loff_t * ppos)
+{
+	int n = devmodules_size - devmodules_ptr;
+
+	if (devmodules_size == 0) {
+		/* Make some space */
+		if (!(devmodulesfile = (char *) get_free_page (GFP_KERNEL)))
+			return -ENOMEM;
+		/* Grab the module list */
+		get_module_list (devmodulesfile);
+		devmodules_ptr = 0;
+		devmodules_size = strlen (devmodulesfile);
+		n = devmodules_size - devmodules_ptr;
+	}
+
+	if (n > count)
+		n = count;
+	if (n <= 0)
+		return 0;
+
+	if (copy_to_user (buf, devmodulesfile, n))
+		return -EFAULT;
+	devmodules_ptr += n;
+	return n;
+}
+
+static int devmodules_open (struct inode *ip, struct file *fp)
+{
+	/* Only let one process use us at any time -- putting other
+	 * processes to sleep.  Those opening us O_NONBLOCK will
+	 * get an EAGAIN error */
+	if ((fp->f_flags & O_NONBLOCK) && devmodules_already_opened) 
+		return -EAGAIN;
+
+	MOD_INC_USE_COUNT;
+
+	while (devmodules_already_opened) {
+		int i, got_signal=0;
+
+		/* Go to sleep until we get woken up 
+		 * by devmodules_close or we receive a signal */
+		module_interruptible_sleep_on(&devmodules_waitq);
+
+		for(i=0; i<_NSIG_WORDS && !got_signal; i++)
+			got_signal = current->signal.sig[i] & ~current->blocked.sig[i];
+
+		/* If we got a signal, decrement the use count
+		 * and return to user space */
+		if (got_signal) {
+			MOD_DEC_USE_COUNT;
+			return -EINTR;
+	        }
+	}
+
+	/* Since we got here, then devmodules_already_opened must equal 0 */
+	devmodules_already_opened=1;
+	devmodules_ptr = 0;
+	devmodules_size = 0;
+
+	return 0;
+}
+
+static int devmodules_release (struct inode *ip, struct file *fp)
+{
+	/* Clean up */
+	if (devmodulesfile != NULL) {
+		free_page ((unsigned long) devmodulesfile);
+		devmodulesfile = NULL;
+	}
+
+	/* Zero out the reference counter */
+	devmodules_already_opened=0;
+
+	/* Wake up anybody that is waiting to access this device */
+	module_wake_up(&devmodules_waitq);
+
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+static int
+devmodules_ioctl (struct inode *ip, struct file *fp,
+	       unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+
+	case DEVMODULES_COUNT_MODULES:{
+#ifdef CONFIG_MODULES
+			return(count_kmodules());
+#else
+			return -ENOSYS;
+#endif
+		}
+
+	case DEVMODULES_GET_MODULES_LIST:{
+#if !defined CONFIG_MODULES
+			return -ENOSYS;
+#else
+
+			int stat, count;
+			struct k_module_item* module_list;
+
+
+			/* How many are there? */
+			count = count_kmodules();
+
+			/* Make some space */
+			module_list = (struct k_module_item *)kmalloc(sizeof(struct k_module_item) * count, GFP_KERNEL);
+			if (!module_list)
+				return -ENOMEM;
+			memset(module_list, 0, sizeof(struct k_module_item) * count);
+
+			/* Grab the list of modules */
+			get_kmodule_list(count, module_list);
+
+			/* Make sure there is enough room */
+			stat = verify_area (VERIFY_WRITE, (struct k_module_item *) arg,
+					    sizeof(struct k_module_item) * count);
+			if (stat) {
+				printk (KERN_INFO
+					"devmodules: Insufficient space was provided.\n");
+				return stat;
+			}
+
+			/* Send it to user space */
+			copy_to_user_ret ((struct k_module_item *) arg, module_list,
+					  sizeof(struct k_module_item) * count, 
+					  -EFAULT);
+
+			/* Clean up */
+			kfree( module_list);
+			return 0;
+#endif
+		}
+
+	default:
+		return -EINVAL;
+
+	}
+	return 0;
+}
+
+
+
+/****************************************************************************
+ * Set up the file operations devmodules will support
+ */
+static struct file_operations devmodules_fops = {
+	devmodules_lseek,
+	devmodules_read,
+	NULL,			/* No write */
+	NULL,			/* No readdir */
+	NULL,			/* No poll */
+	devmodules_ioctl,
+	NULL,			/* No mmap */
+	devmodules_open,
+	NULL,			/* flush */
+	devmodules_release,
+	NULL,			/* fsync */
+	NULL,			/* fasync */
+	NULL,			/* check_media_change */
+	NULL			/* revalidate */
+};
+
+static struct miscdevice devmodules_misc_dev = {
+	DEVMODULES_MINOR,
+	"devmodules",
+	&devmodules_fops
+};
+
+/* The real driver initialization function */
+extern int devmodules_init (void)
+{
+	printk (KERN_INFO "devmodules: driver %s loaded\n", DEVMODULES_VERSION);
+
+	if (misc_register (&devmodules_misc_dev)) {
+		printk ("devmodules: can't register misc device %d\n",
+			DEVMODULES_MINOR);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+#ifdef MODULE
+
+MODULE_AUTHOR ("Erik Andersen <andersee@debian.org>");
+MODULE_DESCRIPTION
+	("devmodules driver -- exports filesystem and mount information to user space");
+
+/* Stub driver initialization function */
+int init_module (void)
+{
+	return (devmodules_init ());
+}
+
+void cleanup_module (void)
+{
+	printk (KERN_INFO "devmodules: driver unloaded\n");
+	misc_deregister (&devmodules_misc_dev);
+}
+
+#endif	/* MODULE */
diff -ur --new-file linux-2.2.15-pre13.virgin/drivers/char/devmtab.c linux/drivers/char/devmtab.c
--- linux-2.2.15-pre13.virgin/drivers/char/devmtab.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/devmtab.c	Tue Mar  7 19:52:45 2000
@@ -0,0 +1,304 @@
+/* vi: set sw=8 ts=8: */
+/*
+ * linux/drivers/char/devmtab.c
+ * 
+ * Copyright (C) 2000 Erik Andersen <andersee@debian.org>
+ *
+ * May be copied or modified under the terms of the GNU General Public License.
+ * See linux/COPYING for more information.
+ *
+ * This driver implements an interface whereby programs such as mount(8),
+ * umount(8), and df(1) may obtain all the process information they need to do
+ * their jobs without needing to use /proc.  This driver another step in my
+ * evil plan to completely dismantle /proc.  Muhahahaha!
+ *
+ * Suggestions are welcome. Patches that work are more welcome though. ;-)
+ *
+ *
+ * When using this driver, running:
+ * 	mknod /dev/mtab c 10 22
+ * could be considered helpful.
+ *
+ * ----------------------------------
+ * 1.00  Mar 07, 2000 -- Initial version.
+ *
+ *************************************************************************/
+
+#define DEVMTAB_VERSION "1.00"
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/malloc.h>
+#include <linux/miscdevice.h>
+#include <linux/devmtab.h>
+#include <linux/wrapper.h>
+#include <asm/pgtable.h>
+#include <asm/uaccess.h>
+
+
+/* Some variables used by this device */
+static struct wait_queue *devmtab_waitq = NULL;
+static int devmtab_already_opened = 0;
+static char *mtabfile = NULL;
+static int mtab_ptr;
+static int mtab_size;
+
+
+
+/****************************************************************************
+ * Handle opening and closing of the device
+ */
+
+static long long
+devmtab_lseek (struct file *file, long long offset, int orig)
+{
+	return -ESPIPE;
+}
+
+static ssize_t
+devmtab_read (struct file *file, char *buf, size_t count, loff_t * ppos)
+{
+	int n = mtab_size - mtab_ptr;
+
+	if (mtab_size == 0) {
+		/* Make some space */
+		if (!(mtabfile = (char *) get_free_page (GFP_KERNEL)))
+			return -ENOMEM;
+		/* Grab the mtab */
+		get_filesystem_info (mtabfile);
+		mtab_ptr = 0;
+		mtab_size = strlen (mtabfile);
+		n = mtab_size - mtab_ptr;
+	}
+
+	if (n > count)
+		n = count;
+	if (n <= 0)
+		return 0;
+
+	if (copy_to_user (buf, mtabfile, n))
+		return -EFAULT;
+	mtab_ptr += n;
+	return n;
+}
+
+static int devmtab_open (struct inode *ip, struct file *fp)
+{
+	/* Only let one process use us at any time -- putting other
+	 * processes to sleep.  Those opening us O_NONBLOCK will
+	 * get an EAGAIN error */
+	if ((fp->f_flags & O_NONBLOCK) && devmtab_already_opened) 
+		return -EAGAIN;
+
+	MOD_INC_USE_COUNT;
+
+	while (devmtab_already_opened) {
+		int i, got_signal=0;
+
+		/* Go to sleep until we get woken up 
+		 * by devmtab_close or we receive a signal */
+		module_interruptible_sleep_on(&devmtab_waitq);
+
+		for(i=0; i<_NSIG_WORDS && !got_signal; i++)
+			got_signal = current->signal.sig[i] & ~current->blocked.sig[i];
+
+		/* If we got a signal, decrement the use count
+		 * and return to user space */
+		if (got_signal) {
+			MOD_DEC_USE_COUNT;
+			return -EINTR;
+	        }
+	}
+
+	/* Since we got here, then devmtab_already_opened must equal 0 */
+	devmtab_already_opened=1;
+	mtab_ptr = 0;
+	mtab_size = 0;
+
+	return 0;
+}
+
+static int devmtab_release (struct inode *ip, struct file *fp)
+{
+	/* Clean up */
+	if (mtabfile != NULL) {
+		free_page ((unsigned long) mtabfile);
+		mtabfile = NULL;
+	}
+
+	/* Zero out the reference counter */
+	devmtab_already_opened=0;
+
+	/* Wake up anybody that is waiting to access this device */
+	module_wake_up(&devmtab_waitq);
+
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+static int
+devmtab_ioctl (struct inode *ip, struct file *fp,
+	       unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+	case DEVMTAB_COUNT_FILESYSTEMS:{
+			return(count_kfstypes());
+		}
+
+	case DEVMTAB_GET_FILESYSTEMS:{
+			int stat, count;
+			struct k_fstype* fstypelist;
+
+			/* How many are there? */
+			count = count_kfstypes();
+
+			/* Make some space */
+			fstypelist = (struct k_fstype *)kmalloc(sizeof(struct k_fstype) * count, GFP_KERNEL);
+			if (!fstypelist)
+				return -ENOMEM;
+			memset(fstypelist, 0, sizeof(struct k_fstype) * count);
+
+			/* Grab the mtab entries */
+			get_kfstype_list(count, fstypelist);
+
+			/* Make sure there is enough room */
+			stat = verify_area (VERIFY_WRITE, (struct k_fstype *) arg,
+					    sizeof(struct k_fstype) * count);
+			if (stat) {
+				printk (KERN_INFO
+					"devmtab: Insufficient space was provided.\n");
+				return stat;
+			}
+
+			/* Send it to user space */
+			copy_to_user_ret ((struct k_fstype *) arg, fstypelist,
+					  sizeof(struct k_fstype) * count, 
+					  -EFAULT);
+
+			/* Clean up */
+			kfree( fstypelist);
+			return 0;
+		}
+
+	case DEVMTAB_COUNT_MOUNTS:{
+			return(count_mounted_filesystems());
+		}
+
+	case DEVMTAB_GET_MOUNTS:{
+			int stat, count;
+			struct k_mntent* mntentlist;
+
+			/* How many are there? */
+			count = count_mounted_filesystems();
+
+			/* Make some space */
+			mntentlist = (struct k_mntent *)kmalloc(sizeof(struct k_mntent) * count, GFP_KERNEL);
+			if (!mntentlist)
+				return -ENOMEM;
+			memset(mntentlist, 0, sizeof(struct k_mntent) * count);
+
+			/* Grab the mtab entries */
+			get_mtab_entries (count, mntentlist);
+
+			/* Make sure there is enough room */
+			stat = verify_area (VERIFY_WRITE, (void*) arg,
+					    sizeof(struct k_mntent) * count);
+			if (stat) {
+				printk (KERN_INFO
+					"devmtab: Insufficient space was provided.\n");
+				return stat;
+			}
+
+			/* Send it to user space */
+			copy_to_user_ret ((struct k_mntent *) arg, mntentlist,
+					  sizeof(struct k_mntent) * count, 
+					  -EFAULT);
+
+			/* Clean up */
+			kfree( mntentlist);
+			return 0;
+		}
+
+	case DEVMTAB_SET_ROOTFS_DEVNAME:{
+			char rootdevname[256];
+
+			copy_from_user_ret (rootdevname, (char*) arg,
+					sizeof(rootdevname), -EFAULT);
+			return( set_root_filesystem_name( rootdevname));
+		}
+
+
+	default:
+		return -EINVAL;
+
+	}
+	return 0;
+}
+
+
+
+/****************************************************************************
+ * Set up the file operations devmtab will support
+ */
+static struct file_operations devmtab_fops = {
+	devmtab_lseek,
+	devmtab_read,
+	NULL,			/* No write */
+	NULL,			/* No readdir */
+	NULL,			/* No poll */
+	devmtab_ioctl,
+	NULL,			/* No mmap */
+	devmtab_open,
+	NULL,			/* flush */
+	devmtab_release,
+	NULL,			/* fsync */
+	NULL,			/* fasync */
+	NULL,			/* check_media_change */
+	NULL			/* revalidate */
+};
+
+static struct miscdevice devmtab_misc_dev = {
+	DEVMTAB_MINOR,
+	"devmtab",
+	&devmtab_fops
+};
+
+/* The real driver initialization function */
+extern int devmtab_init (void)
+{
+	printk (KERN_INFO "devmtab: driver %s loaded\n", DEVMTAB_VERSION);
+
+	if (misc_register (&devmtab_misc_dev)) {
+		printk ("devmtab: can't register misc device %d\n",
+			DEVMTAB_MINOR);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+#ifdef MODULE
+
+MODULE_AUTHOR ("Erik Andersen <andersee@debian.org>");
+MODULE_DESCRIPTION
+	("devmtab driver -- exports filesystem and mount information to user space");
+
+/* Stub driver initialization function */
+int init_module (void)
+{
+	return (devmtab_init ());
+}
+
+void cleanup_module (void)
+{
+	printk (KERN_INFO "devmtab: driver unloaded\n");
+	misc_deregister (&devmtab_misc_dev);
+}
+
+#endif	/* MODULE */
diff -ur --new-file linux-2.2.15-pre13.virgin/drivers/char/devps.c linux/drivers/char/devps.c
--- linux-2.2.15-pre13.virgin/drivers/char/devps.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/devps.c	Tue Mar  7 19:52:45 2000
@@ -0,0 +1,518 @@
+/* vi: set sw=8 ts=8: */
+/*
+ * linux/drivers/char/devps.c
+ * 
+ * Copyright (C) 2000 Erik Andersen <andersee@debian.org>
+ *
+ * May be copied or modified under the terms of the GNU General Public License.
+ * See linux/COPYING for more information.
+ *
+ * This driver implements an interface whereby programs such as ps(1), top(1),
+ * killall(1) and the like may obtain all the process information they need to
+ * do their jobs.  Now you may ask, "Why not use /proc?  BSD uses /proc.".
+ * Thanks for asking.  /proc is designed as a virtual filesystem.  As such it
+ * presents all of its information in a nice, human readable format.  But not
+ * human readable enough that mere mortals can actually look at the /proc
+ * information and know what is happening on their computer (which is why we
+ * have nice programs like ps(1) to help us out.  Additionally, for ps (using
+ * /proc) to do its job, it has to do something like:
+ *
+ *	dir = opendir("/proc");
+ *	while ((entry = readdir(dir)) != NULL) { 
+ *		if (!isdigit(*entry->d_name))
+ *			continue;
+ *		open_lots_of files();
+ *		parse_lots_of_strings();
+ *		close_lots_of_files();
+ *		print_stuff();
+ *	}
+ *
+ *
+ * This is bad, because:
+ *
+ * 1) opening and closing lots of files is slow,
+ *
+ * 2) parsing lots of strings is slow,
+ *
+ * 3) every one of those strings had to be carefully printed out and formatted
+ * by the kernel, which is slow,
+ *
+ * 4) using a virtual filesystem is not the traditional UN*X solution to
+ * getting information from the kernel out to userspace (ioctls and syscalls
+ * are the established way to do this), and worst of all
+ *
+ * 5) having a virtual filesystem around has been so inviting that everyone has
+ * put their own weird little files into it, causing /proc to become a
+ * cluttered rubbish heap of 64 flavors of strange that takes a ridiculous
+ * amount of memory.  
+ *
+ * This driver is the first step in my evil plan to completely 
+ * dismantle /proc.  Muhahahaha!
+ *
+ * Suggestions are welcome. Patches that work are more welcome though. ;-)
+ *
+ * When using this driver, running:
+ * 	mknod /dev/ps c 10 21
+ * could be considered helpful.
+ *
+ * ----------------------------------
+ * 1.00  Mar 07, 2000 -- Initial version.
+ *
+ *
+ * TODO
+ * ----------------------------------
+ *
+ *  * Right now none of the vm or fd info is being returned to user space. 
+ *  * There is probably other stuff that should be exported to user space.
+ *
+ *
+ *************************************************************************/
+
+#define DEVPS_VERSION "1.00"
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/malloc.h>
+#include <linux/miscdevice.h>
+#include <linux/devps.h>
+#include <linux/wrapper.h>
+#include <asm/pgtable.h>
+#include <asm/uaccess.h>
+
+/* Some variables used by this device */
+static struct wait_queue *devps_waitq = NULL;
+static int devps_already_opened = 0;
+
+/****************************************************************************
+ * Handle opening and closing of the device
+ */
+
+static int devps_open (struct inode *ip, struct file *fp)
+{
+	/* Only let one process use us at any time -- putting other
+	 * processes to sleep.  Those opening us O_NONBLOCK will
+	 * get an EAGAIN error */
+	if ((fp->f_flags & O_NONBLOCK) && devps_already_opened) 
+		return -EAGAIN;
+
+	MOD_INC_USE_COUNT;
+
+	while (devps_already_opened) {
+		int i, got_signal=0;
+
+		/* Go to sleep until we get woken up 
+		 * by devps_close or we receive a signal */
+		module_interruptible_sleep_on(&devps_waitq);
+
+		for(i=0; i<_NSIG_WORDS && !got_signal; i++)
+			got_signal = current->signal.sig[i] & ~current->blocked.sig[i];
+
+		/* If we got a signal, decrement the use count
+		 * and return to user space */
+		if (got_signal) {
+			MOD_DEC_USE_COUNT;
+			return -EINTR;
+	        }
+	}
+
+	/* Since we got here, then device_already_opened must equal 0 */
+	devps_already_opened=1;
+	return 0;
+}
+
+static int devps_release (struct inode *ip, struct file *fp)
+{
+	/* Zero out the reference counter */
+	devps_already_opened=0;
+
+	/* Wake up anybody that is waiting to access this device */
+	module_wake_up(&devps_waitq);
+
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+
+/*
+ * This pretty-prints the pathname of a dentry,
+ * clarifying sockets etc.
+ */
+static int
+get_name_from_dentry (struct dentry *dentry, char *buffer, int buflen)
+{
+	struct inode *inode;
+	char *tmp = (char *) __get_free_page (GFP_KERNEL), *path, *pattern;
+	int len;
+
+	if (tmp == NULL)
+		return -ENOMEM;
+
+	/* Check for special dentries.. */
+	pattern = NULL;
+	inode = dentry->d_inode;
+	if (inode && dentry->d_parent == dentry) {
+		if (S_ISSOCK (inode->i_mode))
+			pattern = "socket:[%lu]";
+		if (S_ISFIFO (inode->i_mode))
+			pattern = "pipe:[%lu]";
+	}
+
+	if (pattern) {
+		len = sprintf (tmp, pattern, inode->i_ino);
+		path = tmp;
+	} else {
+		path = d_path (dentry, tmp, PAGE_SIZE);
+		len = tmp + PAGE_SIZE - 1 - path;
+	}
+
+	if (len < buflen)
+		buflen = len;
+	dput (dentry);
+	strncpy (buffer, path, buflen);
+	free_page ((unsigned long) tmp);
+	return buflen;
+}
+
+static unsigned long get_phys_addr (struct task_struct *p,
+				    unsigned long ptr)
+{
+	pgd_t *page_dir;
+	pmd_t *page_middle;
+	pte_t pte;
+
+	if (!p || !p->mm || ptr >= TASK_SIZE)
+		return 0;
+	/* Check for NULL pgd .. shouldn't happen! */
+	if (!p->mm->pgd) {
+		printk ("get_phys_addr: pid %d has NULL pgd!\n", p->pid);
+		return 0;
+	}
+
+	page_dir = pgd_offset (p->mm, ptr);
+	if (pgd_none (*page_dir))
+		return 0;
+	if (pgd_bad (*page_dir)) {
+		printk ("bad page directory entry %08lx\n",
+			pgd_val (*page_dir));
+		pgd_clear (page_dir);
+		return 0;
+	}
+	page_middle = pmd_offset (page_dir, ptr);
+	if (pmd_none (*page_middle))
+		return 0;
+	if (pmd_bad (*page_middle)) {
+		printk ("bad page middle entry %08lx\n",
+			pmd_val (*page_middle));
+		pmd_clear (page_middle);
+		return 0;
+	}
+	pte = *pte_offset (page_middle, ptr);
+	if (!pte_present (pte))
+		return 0;
+	return pte_page (pte) + (ptr & ~PAGE_MASK);
+}
+
+static int get_array (struct task_struct *p, unsigned long start,
+		      unsigned long end, char *buffer)
+{
+	unsigned long addr;
+	int size = 0, result = 0;
+	char c;
+
+	if (start >= end)
+		return result;
+	for (;;) {
+		addr = get_phys_addr (p, start);
+		if (!addr)
+			return result;
+		do {
+			c = *(char *) addr;
+			if (!c)
+				result = size;
+			if (size < PAGE_SIZE)
+				buffer[size++] = c;
+			else
+				return result;
+			addr++;
+			start++;
+			if (!c && start >= end)
+				return result;
+		} while (addr & ~PAGE_MASK);
+	}
+	return result;
+}
+
+static int
+devps_ioctl (struct inode *ip, struct file *fp,
+	     unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+
+	/* Count up the total number of processes, 
+	 * and then return that total */
+	case DEVPS_GET_NUM_PIDS:{
+			struct task_struct *p;
+			pid_t num_pids = 0;
+
+			read_lock (&tasklist_lock);
+			for_each_task (p) {
+				if (!p->pid)
+					continue;
+				num_pids++;
+			}
+			read_unlock (&tasklist_lock);
+
+			copy_to_user_ret ((pid_t *) arg, &num_pids,
+					  sizeof (num_pids), -EFAULT);
+			return 0;
+		}
+
+	/* Returns an array containing all current pids, where
+	   pidlist[0]=number of PIDs in the array. pidlist[0] also
+	   specifies the size of the array for the kernel to
+	   fill... */
+	case DEVPS_GET_PID_LIST:{
+			struct task_struct *p;
+			pid_t *pid_array = NULL;
+			pid_t num_pids;
+			int stat;
+
+			/* Grab the first element to see how many * entries
+			   they want us to fill */
+			stat = verify_area (VERIFY_READ, (char *) arg,
+					     sizeof (pid_t));
+			if (stat) {
+				printk (KERN_INFO
+					"devps: can't tell how many "
+					"to pid's to write.\n");
+				return stat;
+			}
+
+			copy_from_user (&num_pids, (void *) arg,
+					sizeof (num_pids));
+
+			/* Now make sure we can write the specified amount
+			   of stuff into the array.  If we can't we might 
+			   as well quit now and save ourselves the bother. */
+			stat = verify_area (VERIFY_WRITE, (char *) arg,
+					     sizeof (pid_t) * num_pids);
+			if (stat) {
+				printk (KERN_INFO
+					"devps: Insufficient space was "
+					"provided to write %d pid's.\n",
+					num_pids);
+				return stat;
+			}
+
+			/* Allocate some memory to hold this stuff in before
+			   * we copy it out to user-space */
+			pid_array = (pid_t *) kmalloc (num_pids *
+						   sizeof (pid_t),
+						   GFP_KERNEL);
+			if (pid_array == NULL)
+				return -ENOMEM;
+
+			/* Now march through the PID list */
+			pid_array[0] = 0;
+			read_lock (&tasklist_lock);
+			for_each_task (p) {
+				if (!p->pid)
+					continue;
+				(pid_array[0])++;
+				if (pid_array[0] >= (num_pids - 1))
+					continue;
+				pid_array[pid_array[0]] = p->pid;
+			}
+			read_unlock (&tasklist_lock);
+
+			/* Copy out to the user the number we actually filled 
+			 */
+			copy_to_user_ret ((void *) arg, pid_array,
+					  sizeof (pid_t) * pid_array[0],
+					  -EFAULT);
+			kfree (pid_array);
+
+			return 0;
+		}
+
+	/* Find the details on a particular pid, and fill out a
+	   struct with all the gory details. */
+	case DEVPS_GET_PID_INFO:{
+			struct task_struct *p;
+			struct pid_info mypidinfo;
+			unsigned int state;
+			/* 'R' running    */
+			/* 'S' sleeping   */
+			/* 'D' disk sleep */
+			/* 'Z' zombie     */
+			/* 'T' stopped    */
+			/* 'W' paging     */
+			const char *state_string = "RSDZTW";
+
+			copy_from_user_ret (&mypidinfo,
+					    (struct pid_info *) arg,
+					    sizeof (mypidinfo), -EFAULT);
+
+			read_lock (&tasklist_lock);
+			p = find_task_by_pid (mypidinfo.pid);
+			read_unlock (&tasklist_lock);
+
+			/* Now copy all this crap so we can tell user space 
+			   all about it.  ick.  */
+			memset (mypidinfo.name, 0,
+				sizeof (mypidinfo.name));
+			strcpy (mypidinfo.name, p->comm);
+			mypidinfo.flags = p->flags;
+			mypidinfo.pgrp = p->pgrp;
+			mypidinfo.tms_cutime = p->times.tms_cutime;
+			mypidinfo.tms_cstime = p->times.tms_cstime;
+			mypidinfo.tms_utime = p->times.tms_utime;
+			mypidinfo.tms_stime = p->times.tms_stime;
+			mypidinfo.min_flt = p->min_flt;
+			mypidinfo.cmin_flt = p->cmin_flt;
+			mypidinfo.maj_flt = p->maj_flt;
+			mypidinfo.cmaj_flt = p->cmaj_flt;
+			mypidinfo.session = p->session;
+			mypidinfo.pid = p->pid;
+			mypidinfo.ppid = p->p_pptr->pid;
+			mypidinfo.tty =
+				p->tty ? kdev_t_to_nr (p->tty->device) : 0;
+			mypidinfo.start_time = p->start_time;
+			mypidinfo.uid = p->uid;
+			mypidinfo.euid = p->euid;
+			mypidinfo.suid = p->suid;
+			mypidinfo.fsuid = p->fsuid;
+			mypidinfo.gid = p->gid;
+			mypidinfo.egid = p->egid;
+			mypidinfo.sgid = p->sgid;
+			mypidinfo.fsgid = p->fsgid;
+			mypidinfo.priority = 20 - (p->counter * 10 + 
+					DEF_PRIORITY / 2) / DEF_PRIORITY;
+			mypidinfo.nice = 20 - (mypidinfo.priority * 20 +
+				      DEF_PRIORITY / 2) / DEF_PRIORITY;
+			state = p-> state & (TASK_RUNNING | TASK_INTERRUPTIBLE
+					 | TASK_UNINTERRUPTIBLE |
+					 TASK_ZOMBIE | TASK_STOPPED |
+					 TASK_SWAPPING);
+			while (state) {
+				state_string++;
+				state >>= 1;
+			}
+			mypidinfo.state = *state_string;
+			mypidinfo.processor = p->processor;
+			mypidinfo.nswap = p->nswap;
+			mypidinfo.cnswap = p->cnswap;
+			if (p && p->mm) {
+				char *page = NULL;
+
+				/* Look for some elbow room */
+				if (!(page = (char*)get_free_page (GFP_KERNEL)))
+					return -ENOMEM;
+				/* Grab the command line */
+				get_array (p, p->mm->arg_start,
+					   p->mm->arg_end, page);
+				memcpy( mypidinfo.command_line, page, sizeof( mypidinfo.command_line));
+				mypidinfo.command_line[sizeof( mypidinfo.command_line)-1]='\0';
+
+				/* Grab the environment */
+				memset (page, 0, PAGE_SIZE);
+				get_array (p, p->mm->env_start,
+					   p->mm->env_end, page);
+				memcpy( mypidinfo.environment, page, sizeof( mypidinfo.environment));
+				mypidinfo.command_line[sizeof( mypidinfo.environment)-1]='\0';
+				free_page ((unsigned long) page);
+			}
+			memset (mypidinfo.cwd, 0, sizeof (mypidinfo.cwd));
+			get_name_from_dentry (dget (p->fs->pwd), mypidinfo.cwd,
+					      sizeof (mypidinfo.cwd));
+			memset (mypidinfo.root, 0, sizeof (mypidinfo.root));
+			get_name_from_dentry (dget (p->fs->root),
+					      mypidinfo.root,
+					      sizeof (mypidinfo.root));
+
+			copy_to_user_ret ((struct pid_info *) arg,
+					  &mypidinfo, sizeof (mypidinfo),
+					  -EFAULT);
+
+			return 0;
+		}
+
+	/* Return the PID of the current process */
+	case DEVPS_GET_CURRENT_PID:{
+			return current->pid;
+		}
+
+	default:
+		return -EINVAL;
+
+	}
+	return 0;
+}
+
+
+
+/****************************************************************************
+ * Set up the file operations devps will support
+ */
+static struct file_operations devps_fops = {
+	NULL,			/* No lseek */
+	NULL,			/* No read */
+	NULL,			/* No write */
+	NULL,			/* No readdir */
+	NULL,			/* No poll */
+	devps_ioctl,
+	NULL,			/* No mmap */
+	devps_open,
+	NULL,			/* flush */
+	devps_release,
+	NULL,			/* fsync */
+	NULL,			/* fasync */
+	NULL,			/* check_media_change */
+	NULL			/* revalidate */
+};
+
+static struct miscdevice devps_misc_dev = {
+	DEVPS_MINOR,
+	"devps",
+	&devps_fops
+};
+
+/* The real driver initialization function */
+extern int devps_init (void)
+{
+	printk (KERN_INFO "devps driver %s loaded\n", DEVPS_VERSION);
+
+	if (misc_register (&devps_misc_dev)) {
+		printk ("devps: unable to get misc device %d\n",
+			DEVPS_MINOR);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+#ifdef MODULE
+
+MODULE_AUTHOR ("Erik Andersen <andersee@debian.org>");
+MODULE_DESCRIPTION
+	("devps driver -- exports kernel process information to user space");
+
+
+/* Stub driver initialization function */
+int init_module (void)
+{
+	return (devps_init ());
+}
+
+void cleanup_module (void)
+{
+	printk (KERN_INFO "devps driver unloaded\n");
+	misc_deregister (&devps_misc_dev);
+}
+
+#endif				/* endif MODULE */
diff -ur --new-file linux-2.2.15-pre13.virgin/drivers/char/makedevps.sh linux/drivers/char/makedevps.sh
--- linux-2.2.15-pre13.virgin/drivers/char/makedevps.sh	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/makedevps.sh	Tue Mar  7 23:31:52 2000
@@ -0,0 +1,6 @@
+#!/bin/sh -x
+
+gcc -Wall -g -I /usr/src/linux/include ps-devps.c -o ps-devps
+gcc -Wall -g -I /usr/src/linux/include mounts.c -o mounts
+gcc -Wall -g -I /usr/src/linux/include modules.c -o modules
+
diff -ur --new-file linux-2.2.15-pre13.virgin/drivers/char/misc.c linux/drivers/char/misc.c
--- linux-2.2.15-pre13.virgin/drivers/char/misc.c	Tue Mar  7 19:46:58 2000
+++ linux/drivers/char/misc.c	Tue Mar  7 19:52:45 2000
@@ -84,6 +84,8 @@
 extern void hfmodem_init(void);
 extern int pc110pad_init(void);
 extern int pmu_device_init(void);
+extern int devps_init(void);
+extern int devmtab_init(void);
 
 static int misc_read_proc(char *buf, char **start, off_t offset,
 			  int len, int *eof, void *private)
@@ -267,6 +269,12 @@
 #endif
 #ifdef CONFIG_PMAC_PBOOK
 	pmu_device_init();
+#endif
+#ifdef CONFIG_DEVPS
+	devps_init();
+#endif
+#ifdef CONFIG_DEVMTAB
+	devmtab_init();
 #endif
 #ifdef CONFIG_SGI_NEWPORT_GFX
 	gfx_register ();
diff -ur --new-file linux-2.2.15-pre13.virgin/drivers/char/modules.c linux/drivers/char/modules.c
--- linux-2.2.15-pre13.virgin/drivers/char/modules.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/modules.c	Tue Mar  7 23:35:26 2000
@@ -0,0 +1,102 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * devmodules tester
+ *
+ *
+ * Copyright (C) 2000 by Erik Andersen <andersee@debian.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <linux/devmodules.h>
+
+
+int main (int argc, char **argv)
+{
+	char device[80] = "/dev/modules";
+	int fd;           /* file descriptor for devmodules device */
+	int i, num_modules;
+	struct k_module_item *modlist;
+
+	if (argc > 1 && **(argv + 1) == '-') {
+		fprintf(stderr, "Usage: modules\n\nLists loaded modules\n\nThis version of modules accepts no options.\n\n");
+		exit(1);
+	}
+
+	/* open device */ 
+	fd = open(device, O_RDONLY);
+	if (fd < 0) {
+		fprintf (stderr, "open failed for `%s': %s\n",
+			 device, strerror (errno));
+		exit (1);
+	}
+
+	/* How many modules?  We need to know to allocate 
+	 * enough space for later... */
+	num_modules = ioctl (fd, DEVMODULES_COUNT_MODULES);
+	if (num_modules<0) {
+		fprintf (stderr, "\nDEVMODULES_COUNT_MODULES: %s\n", 
+			strerror (errno));
+		exit (1);
+	} 
+	modlist = (struct k_module_item *) calloc ( num_modules, sizeof(struct k_module_item));
+
+	/* Grab the list of loaded modules  */
+	if (ioctl (fd, DEVMODULES_GET_MODULES_LIST, modlist)<0) {
+		fprintf (stderr, "\nDEVMODULES_GET_MODULES_LIST: %s\n", 
+			strerror (errno));
+		exit (1);
+	} 
+	fprintf( stdout, "\nEquivalent of /proc/modules:\n");
+	for( i = 0 ; i < num_modules ; i++) {
+		fprintf( stdout, "%-20s%8lu%4ld", modlist[i].name,
+				modlist[i].size, modlist[i].usecount); 
+		if (modlist[i].flags & MOD_DELETED)
+			fprintf( stdout, " (deleted)");
+		else if (modlist[i].flags & MOD_RUNNING) {
+			if (modlist[i].flags & MOD_AUTOCLEAN)
+				fprintf( stdout, " (autoclean)");
+			if (!(modlist[i].flags & MOD_USED_ONCE))
+				fprintf( stdout, " (unused)");
+		}
+		else if (modlist[i].flags & MOD_INITIALIZING)
+			fprintf( stdout, " (initializing)");
+		else
+			fprintf( stdout, " (uninitialized)");
+		/* TODO: Add in module reference list */
+		fprintf( stdout, "\n");
+	}
+
+	/* Clean up */
+	free( modlist);
+	if (close (fd) != 0) {
+		fprintf (stderr, "close failed for `%s': %s\n",
+			 device, strerror (errno));
+		exit (1);
+	}
+ 
+	exit (0);
+}
+
diff -ur --new-file linux-2.2.15-pre13.virgin/drivers/char/mounts.c linux/drivers/char/mounts.c
--- linux-2.2.15-pre13.virgin/drivers/char/mounts.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/mounts.c	Tue Mar  7 23:29:27 2000
@@ -0,0 +1,124 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * devmtab tester
+ *
+ *
+ * Copyright (C) 2000 by Erik Andersen <andersee@debian.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <linux/devmtab.h>
+
+
+int main (int argc, char **argv)
+{
+	char device[80] = "/dev/mtab";
+	int fd;           /* file descriptor for devmtab device */
+	int i, numfilesystems;
+	struct k_fstype *fslist;
+	struct k_mntent *mntentlist;
+
+	if (argc > 1 && **(argv + 1) == '-') {
+		fprintf(stderr, "Usage: mounts\n\nReport mounted stuff\n\nThis version of mounts accepts no options.\n\n");
+		exit(1);
+	}
+
+	/* open device */ 
+	if ((fd = open(device, O_RDONLY)) < 0) {
+		fprintf (stderr, "open failed for `%s': %s\n",
+			 device, strerror (errno));
+		exit (1);
+	}
+
+	/* How many filesystems?  We need to know to allocate 
+	 * enough space for later... */
+	numfilesystems = ioctl (fd, DEVMTAB_COUNT_FILESYSTEMS);
+	if (numfilesystems<0) {
+		fprintf (stderr, "\nDEVMTAB_COUNT_FILESYSTEMS: %s\n", 
+			strerror (errno));
+		exit (1);
+	} 
+	fslist = (struct k_fstype *) calloc ( numfilesystems, sizeof(struct k_fstype));
+
+	/* Grab the list of available filesystems */
+	if (ioctl (fd, DEVMTAB_GET_FILESYSTEMS, fslist)<0) {
+		fprintf (stderr, "\nDEVMTAB_GET_FILESYSTEMS: %s\n", 
+			strerror (errno));
+		exit (1);
+	} 
+	fprintf( stdout, "\nEquivalent of /proc/filesystems:\n");
+	for( i = 0 ; i < numfilesystems ; i++) {
+		fprintf( stdout, "%s%s\n", fslist[i].mnt_type, 
+				(fslist[i].mnt_nodev)? " nodev" : "");
+	}
+
+
+	/* How many mounted filesystems?  We need to know to 
+	 * allocate enough space for later... */
+	numfilesystems = ioctl (fd, DEVMTAB_COUNT_MOUNTS);
+	if (numfilesystems<0) {
+		fprintf (stderr, "\nDEVMTAB_COUNT_MOUNTS: %s\n", 
+			strerror (errno));
+		exit (1);
+	} 
+	mntentlist = (struct k_mntent *) calloc ( numfilesystems, sizeof(struct k_mntent));
+	
+	/* Grab the list of mounted filesystems */
+	if (ioctl (fd, DEVMTAB_GET_MOUNTS, mntentlist)<0) {
+		fprintf (stderr, "\nDEVMTAB_GET_MOUNTS: %s\n", 
+			strerror (errno));
+		exit (1);
+	} 
+
+	fprintf( stdout, "\nEquivalent of /proc/mounts:\n");
+	for( i = 0 ; i < numfilesystems ; i++) {
+		fprintf( stdout, "%s %s %s %s %d %d\n", mntentlist[i].mnt_fsname,
+				mntentlist[i].mnt_dir, mntentlist[i].mnt_type, 
+				mntentlist[i].mnt_opts, mntentlist[i].mnt_freq, 
+				mntentlist[i].mnt_passno);
+	}
+
+
+	/* Change the root filesystem's device name */
+	if (ioctl (fd, DEVMTAB_SET_ROOTFS_DEVNAME, "/dev/foo")<0) {
+		fprintf (stderr, "\nDEVMTAB_SET_ROOTFS_DEVNAME: %s\n", 
+			strerror (errno));
+		exit (1);
+	} 
+
+	
+	/* clean up */
+	free( fslist);
+	free( mntentlist);
+	if (close (fd) != 0) {
+		fprintf (stderr, "close failed for `%s': %s\n",
+			 device, strerror (errno));
+		exit (1);
+	}
+ 
+	exit (0);
+}
+
diff -ur --new-file linux-2.2.15-pre13.virgin/drivers/char/ps-devps.c linux/drivers/char/ps-devps.c
--- linux-2.2.15-pre13.virgin/drivers/char/ps-devps.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/ps-devps.c	Tue Mar  7 19:52:45 2000
@@ -0,0 +1,147 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Mini ps implementation for use with the Linux devps driver
+ *
+ *
+ * Copyright (C) 2000 by Erik Andersen <andersee@debian.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <linux/devps.h>
+#include <pwd.h>
+#include <grp.h>
+#include <sys/types.h>
+
+
+#define MAX_COLUMN	79
+
+int
+main (int argc, char **argv)
+{
+	char device[80] = "/dev/ps";
+	int i, j, len;
+	int fd;           /* file descriptor for devps device */
+	int status;       /* return status for system calls */
+	pid_t num_pids;
+	pid_t* pid_array = NULL;
+	struct pid_info info;
+	struct passwd *pwd;
+	struct group *grp;
+	char uidName[10] = "";
+	char groupName[10] = "";
+
+	if (argc > 1 && **(argv + 1) == '-') {
+		fprintf(stderr, "Usage: ps-devps\n\nReport process status\n\nThis version of ps accepts no options.\n\n");
+		exit(1);
+	}
+
+	/* open device */ 
+	fd = open(device, O_RDWR);
+	if (fd < 0) {
+		fprintf (stderr, "open failed for `%s': %s\n",
+			 device, strerror (errno));
+		goto error;
+	}
+
+	/* Find out how many processes there are */
+	status = ioctl (fd, DEVPS_GET_NUM_PIDS, &num_pids);
+	if (status<0) {
+		fprintf (stderr, "\nDEVPS_GET_PID_LIST: %s\n", 
+			strerror (errno));
+		goto error;
+	} 
+	
+	/* Allocate some memory -- grab a few extras just in case 
+	 * some new processes start up while we wait. The kernel will
+	 * just ignore any extras if we give it too many, and will trunc.
+	 * the list if we give it too few.  */
+	pid_array = (pid_t*) calloc( num_pids+10, sizeof(pid_t));
+	pid_array[0] = num_pids+10;
+
+	/* Now grab the pid list */
+	status = ioctl (fd, DEVPS_GET_PID_LIST, pid_array);
+	if (status<0) {
+		fprintf (stderr, "\nDEVPS_GET_PID_LIST: %s\n", 
+			strerror (errno));
+		goto error;
+	} 
+
+	/* Print up a ps listing */
+	fprintf(stdout, "%5s  %-8s %-3s %5s %s\n", "PID", "Uid", "Gid",
+			"State", "Command");
+
+	for (i=1; i<pid_array[0] ; i++) {
+	    info.pid = pid_array[i];
+	    status = ioctl (fd, DEVPS_GET_PID_INFO, &info);
+	    if (status<0) {
+		    fprintf (stderr, "\nDEVPS_GET_PID_INFO: %s\n", 
+			    strerror (errno));
+		    goto error;
+	    } 
+		/* Make some adjustments as needed */
+		pwd = getpwuid(info.euid);
+		if (pwd == NULL)
+			sprintf(uidName, "%lu", info.euid);
+		else
+			sprintf(uidName, "%s", pwd->pw_name);
+		grp = getgrgid(info.egid);
+		if (grp == NULL)
+			sprintf(groupName, "%lu", info.egid);
+		else
+			sprintf(groupName, "%s", grp->gr_name);
+
+		len = fprintf(stdout, "%5d %-8s %-8s %c ", info.pid, uidName, groupName, info.state);
+
+		if (strlen(info.command_line) > 1) {
+			for( j=0; j<(sizeof(info.command_line)-1) && j < (MAX_COLUMN-len); j++) {
+				if (*(info.command_line+j) == '\0' && *(info.command_line+j+1) != '\0') {
+					*(info.command_line+j) = ' ';
+				}
+			}
+			*(info.command_line+j) = '\0';
+			fprintf(stdout, "%s\n", info.command_line);
+		} else {
+			fprintf(stdout, "[%s]\n", info.name);
+		}
+	}
+
+	/* Free memory */
+	free( pid_array);
+
+	/* close device */
+	status = close (fd);
+	if (status != 0) {
+		fprintf (stderr, "close failed for `%s': %s\n",
+			 device, strerror (errno));
+		goto error;
+	}
+ 
+	exit (0);
+error:
+	fflush(stdout);
+	fflush(stderr);
+	exit (1);
+}
+
diff -ur --new-file linux-2.2.15-pre13.virgin/fs/Makefile linux/fs/Makefile
--- linux-2.2.15-pre13.virgin/fs/Makefile	Mon Mar  6 10:23:14 2000
+++ linux/fs/Makefile	Tue Mar  7 19:52:45 2000
@@ -11,9 +11,10 @@
 L_OBJS    = $(join $(SUB_DIRS),$(SUB_DIRS:%=/%.o))
 O_TARGET := fs.o
 O_OBJS    = open.o read_write.o devices.o file_table.o buffer.o \
-		super.o  block_dev.o stat.o exec.o pipe.o namei.o fcntl.o \
+		block_dev.o stat.o exec.o pipe.o namei.o fcntl.o \
 		ioctl.o readdir.o select.o fifo.o locks.o filesystems.o \
 		dcache.o inode.o attr.o bad_inode.o file.o $(BINFMTS) 
+OX_OBJS = super.o
 
 MOD_LIST_NAME := FS_MODULES
 ALL_SUB_DIRS = coda minix ext2 fat msdos vfat proc isofs nfs umsdos ntfs \
diff -ur --new-file linux-2.2.15-pre13.virgin/fs/proc/array.c linux/fs/proc/array.c
--- linux-2.2.15-pre13.virgin/fs/proc/array.c	Tue Mar  7 19:47:04 2000
+++ linux/fs/proc/array.c	Tue Mar  7 19:52:45 2000
@@ -44,6 +44,7 @@
  *
  */
 
+#include <linux/module.h>
 #include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
@@ -1306,10 +1307,6 @@
 }
 #endif
 
-#ifdef CONFIG_MODULES
-extern int get_module_list(char *);
-extern int get_ksyms_list(char *, char **, off_t, int);
-#endif
 extern int get_device_list(char *);
 extern int get_partition_list(char *);
 extern int get_filesystem_list(char *);
diff -ur --new-file linux-2.2.15-pre13.virgin/fs/super.c linux/fs/super.c
--- linux-2.2.15-pre13.virgin/fs/super.c	Tue Jan  4 11:12:23 2000
+++ linux/fs/super.c	Tue Mar  7 19:52:45 2000
@@ -18,6 +18,7 @@
  */
 
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/malloc.h>
 #include <linux/locks.h>
 #include <linux/smp_lock.h>
@@ -25,6 +26,7 @@
 #include <linux/init.h>
 #include <linux/quotaops.h>
 #include <linux/acct.h>
+#include <linux/devmtab.h>
 
 #include <asm/uaccess.h>
 
@@ -309,7 +311,57 @@
 	{ 0, NULL }
 };
 
-int get_filesystem_info( char *buf )
+
+extern int count_mounted_filesystems()
+{
+	struct vfsmount *tmp = vfsmntlist;
+	int count = 0;
+
+	while (tmp)
+	{
+		tmp = tmp->mnt_next;
+		count++;
+	}
+
+	return count;
+}
+EXPORT_SYMBOL(count_mounted_filesystems);
+
+
+extern void get_mtab_entries( int count, struct k_mntent* mntentlist)
+{
+	struct vfsmount *tmp = vfsmntlist;
+	struct proc_fs_info *fs_infop;
+	int i = 0, len;
+
+	while (tmp && i < count)
+	{
+		strncpy(mntentlist[i].mnt_fsname, tmp->mnt_devname, 
+				sizeof(mntentlist[i].mnt_fsname));
+		strncpy(mntentlist[i].mnt_dir, tmp->mnt_dirname, 
+				sizeof(mntentlist[i].mnt_dir));
+		strncpy(mntentlist[i].mnt_type, tmp->mnt_sb->s_type->name,
+				sizeof(mntentlist[i].mnt_type));
+		len = 0;
+		len+=sprintf(mntentlist[i].mnt_opts, "%s", 
+				tmp->mnt_flags & MS_RDONLY ? "ro" : "rw");
+		for (fs_infop = fs_info; fs_infop->flag; fs_infop++) {
+		  if (tmp->mnt_flags & fs_infop->flag) {
+		    strncpy(mntentlist[i].mnt_opts+len, fs_infop->str, 
+				    sizeof(mntentlist[i].mnt_opts)-len);
+		    len += strlen(fs_infop->str);
+		  }
+		}
+
+		/* TODO -- add in NFS stuff */ 
+
+		tmp = tmp->mnt_next;
+		i++;
+	}
+}
+EXPORT_SYMBOL(get_mtab_entries);
+
+extern int get_filesystem_info( char *buf )
 {
 	struct vfsmount *tmp = vfsmntlist;
 	struct proc_fs_info *fs_infop;
@@ -379,8 +431,54 @@
 
 	return len;
 }
+EXPORT_SYMBOL(get_filesystem_info);
+
+extern int count_kfstypes()
+{
+	struct file_system_type * tmp = file_systems;
+	int count = 0;
+
+	while (tmp) {
+		count++;
+		tmp = tmp->next;
+	}
+
+	return count;
+}
+EXPORT_SYMBOL(count_kfstypes);
+
+extern int set_root_filesystem_name( char *newname)
+{
+	struct vfsmount *tmp = vfsmntlist;
+	char *name;
+
+	if (tmp && newname) {
+		kfree( tmp->mnt_devname);
+		name = (char *) kmalloc(strlen(newname)+1, GFP_KERNEL);
+		if (!name)
+			return -ENOMEM;
+		strcpy(name, newname);
+		tmp->mnt_devname = name;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(set_root_filesystem_name);
+
+extern void get_kfstype_list(int count, struct k_fstype* fstypelist)
+{
+	int i = 0;
+	struct file_system_type * tmp = file_systems;
+
+	while (tmp && i < count) {
+		strncpy(fstypelist[i].mnt_type, tmp->name, sizeof(fstypelist[i].mnt_type));
+		fstypelist[i].mnt_nodev = (tmp->fs_flags & FS_REQUIRES_DEV)? 0 : 1;
+		tmp = tmp->next;
+		i++;
+	}
+}
+EXPORT_SYMBOL(get_kfstype_list);
 
-int get_filesystem_list(char * buf)
+extern int get_filesystem_list(char * buf)
 {
 	int len = 0;
 	struct file_system_type * tmp;
@@ -394,6 +492,7 @@
 	}
 	return len;
 }
+EXPORT_SYMBOL(get_filesystem_list);
 
 struct file_system_type *get_fs_type(const char *name)
 {
diff -ur --new-file linux-2.2.15-pre13.virgin/include/linux/devmodules.h linux/include/linux/devmodules.h
--- linux-2.2.15-pre13.virgin/include/linux/devmodules.h	Wed Dec 31 17:00:00 1969
+++ linux/include/linux/devmodules.h	Tue Mar  7 23:37:48 2000
@@ -0,0 +1,55 @@
+/* vi: set sw=8 ts=8: */
+/*
+ * -- <linux/devmodules.h>
+ *  
+ * Copyright (C) 2000 Erik Andersen <andersee@debian.org>
+ * 
+ * May be copied or modified under the terms of the GNU General Public License.
+ * See linux/COPYING for more information.
+ *
+ * This driver implements an interface whereby programs such as lsmod(8) may
+ * obtain all the information they need to do their jobs without needing to 
+ * use /proc.
+ *
+ */
+ 
+#ifndef	_LINUX_DEVMODULES_H
+#define	_LINUX_DEVMODULES_H
+
+
+/*******************************************************
+ * The list of all ioctl(2) commands suported by devmodules.
+ * For the devmodules ioctls, I have commandeered some of the
+ * higher bits of byte 0xeb.
+ *******************************************************/
+#define DEVMODULES_COUNT_MODULES      0xebba /* How many modules are there? */ 
+#define DEVMODULES_GET_MODULES_LIST   0xebbb /* Get a list of all installed modules */ 
+
+/*******************************************************
+ * devmodules ioctl(2) structures
+ *******************************************************/
+
+/* An array of these is returned by the DEVMODULES_GET_MODULES_LIST ioctl.
+ */
+struct k_module_item {
+	char          name[255];/* Name of the module */
+	unsigned long size;     /* Size of module in bytes */
+	unsigned long flags;    /* Flags set by the module */
+	long usecount;          /* Module use count value */
+
+	/* TODO: Add in module reference list */
+
+};
+
+/* Possible bits for k_module_item's flags.  */
+#define MOD_UNINITIALIZED       0
+#define MOD_RUNNING             1
+#define MOD_DELETED             2
+#define MOD_AUTOCLEAN           4
+#define MOD_VISITED             8
+#define MOD_USED_ONCE           16
+#define MOD_JUST_FREED          32
+#define MOD_INITIALIZING        64
+
+
+#endif  /* _LINUX_DEVMODULES_H */
diff -ur --new-file linux-2.2.15-pre13.virgin/include/linux/devmtab.h linux/include/linux/devmtab.h
--- linux-2.2.15-pre13.virgin/include/linux/devmtab.h	Wed Dec 31 17:00:00 1969
+++ linux/include/linux/devmtab.h	Tue Mar  7 19:52:45 2000
@@ -0,0 +1,55 @@
+/* vi: set sw=8 ts=8: */
+/*
+ * -- <linux/devmtab.h>
+ *  
+ * Copyright (C) 2000 Erik Andersen <andersee@debian.org>
+ * 
+ * May be copied or modified under the terms of the GNU General Public License.
+ * See linux/COPYING for more information.
+ *
+ * This driver implements an interface whereby programs such as mount(8),
+ * umount(8), and df(1) may obtain all the process information they need to do
+ * their jobs without needing to use /proc.
+ *
+ */
+ 
+#ifndef	_LINUX_DEVMTAB_H
+#define	_LINUX_DEVMTAB_H
+
+
+/*******************************************************
+ * The list of all ioctl(2) commands suported by devmtab.
+ * For the devmtab ioctls, I have commandeered some of the
+ * higher bits of byte 0xeb.
+ *******************************************************/
+#define DEVMTAB_COUNT_FILESYSTEMS  0xebaa /* Get a list of all fs */ 
+#define DEVMTAB_GET_FILESYSTEMS    0xebab /* Get a list of all fs */ 
+#define DEVMTAB_COUNT_MOUNTS       0xebac /* Returns number of mounted filesystems */
+#define DEVMTAB_GET_MOUNTS         0xebad /* Get a list of a mounted fs */
+#define DEVMTAB_SET_ROOTFS_DEVNAME 0xebae /* Replace /dev/root with real name */
+
+/*******************************************************
+ * devmtab ioctl(2) structures
+ *******************************************************/
+
+/* An array of these is returned by the DEVMTAB_GET_FILESYSTEMS ioctl.
+ */
+struct k_fstype {
+	char    mnt_type[255];   /* filesystem type: ext2, nfs, etc. */
+	int     mnt_nodev;       /* Is this a device-less filesystem? */
+};
+
+/* An array of these is returned by the DEVMTAB_GET_MOUNTS ioctl.
+ * This struct should be the same as what libc returns via the
+ * getmntent(3) function (excat this comes from the kernel, not
+ * from whatever noise is in /etc/mtab at the moment... */
+struct k_mntent {
+	char    mnt_fsname[255];    /* name of mounted file system */
+	char    mnt_dir[255];       /* path of file system mount point */
+	char    mnt_type[255];      /* filesystem type: ext2, nfs, etc. */
+	char    mnt_opts[255];      /* Comma-separated list of mount options */
+	int     mnt_freq;       /* dump frequency in days */
+	int     mnt_passno;     /* pass number for parallel fsck */
+};
+
+#endif  /* _LINUX_DEVMTAB_H */
diff -ur --new-file linux-2.2.15-pre13.virgin/include/linux/devps.h linux/include/linux/devps.h
--- linux-2.2.15-pre13.virgin/include/linux/devps.h	Wed Dec 31 17:00:00 1969
+++ linux/include/linux/devps.h	Tue Mar  7 19:52:45 2000
@@ -0,0 +1,78 @@
+/*
+ * -- <linux/devps.h>
+ *  
+ * Copyright (C) 2000 Erik Andersen <andersee@debian.org>
+ * 
+ * May be copied or modified under the terms of the GNU General Public License.
+ * See linux/COPYING for more information.
+ *
+ * This driver implements an interface whereby programs such as ps(1), top(1),
+ * killall(1) and the like may obtain all the process information they need to
+ * do their jobs.
+ *
+ */
+ 
+#ifndef	_LINUX_DEVPS_H
+#define	_LINUX_DEVPS_H
+
+
+/*******************************************************
+ * The list of all ioctl(2) commands suported by devps.
+ * For the devps ioctls, I have commandeered some of the
+ * higher bits of byte 0xeb.
+ *******************************************************/
+#define DEVPS_GET_NUM_PIDS	0xeba1 /* Get a list of all PIDs */ 
+#define DEVPS_GET_PID_LIST	0xeba2 /* Get a list of all PIDs */ 
+#define DEVPS_GET_PID_INFO	0xeba3 /* Get info about a specific PID */
+#define DEVPS_GET_CURRENT_PID	0xeba4 /* Get the current PID */
+
+/*******************************************************
+ * devps ioctl(2) structures
+ *******************************************************/
+
+
+struct pid_info
+{
+	char  name[16];
+	long flags;
+	pid_t pgrp;
+	clock_t tms_cutime;
+	clock_t tms_cstime;
+	clock_t tms_utime;
+	clock_t tms_stime;
+	unsigned long min_flt;
+	unsigned long cmin_flt;
+	unsigned long maj_flt;
+	unsigned long cmaj_flt;
+	pid_t session;
+	pid_t pid;
+	pid_t ppid;
+	int tty;
+	unsigned long start_time;
+	unsigned long uid,euid,suid,fsuid;
+	unsigned long gid,egid,sgid,fsgid;
+	long priority, nice;
+	char state;
+	int processor;
+	unsigned long nswap, cnswap;
+	char command_line[256];
+	char environment[256];
+	char root[256];
+	char cwd[256];
+#if 0
+	/* TODO: Add in this (and probably more) stuff */
+
+	int resident;
+	int size;
+	int share;
+	unsigned long vsize;
+	char exe[MAX_PATH];
+	unsigned long vm_total, vm_locked, vm_rss, vm_data, vm_stack, vm_exec, vm_lib;
+	unsigned long start_code, end_code, start_data, eip, esp;
+	unsigned long signal, blocked;
+#endif
+
+
+};
+
+#endif  /* _LINUX_DEVPS_H */
diff -ur --new-file linux-2.2.15-pre13.virgin/include/linux/fs.h linux/include/linux/fs.h
--- linux-2.2.15-pre13.virgin/include/linux/fs.h	Mon Mar  6 10:23:14 2000
+++ linux/include/linux/fs.h	Tue Mar  7 21:14:11 2000
@@ -566,6 +566,17 @@
 	struct semaphore s_vfs_rename_sem;	/* Kludge */
 };
 
+/* fs/super.c */
+#include <linux/devmtab.h>
+
+extern int count_kfstypes( void);
+extern void get_kfstype_list( int count, struct k_fstype* fstypelist); 
+extern int count_mounted_filesystems( void);
+extern int get_filesystem_info(char *buf);
+extern int get_filesystem_list(char *buf);
+extern void get_mtab_entries( int count, struct k_mntent* mntentlist);
+extern int set_root_filesystem_name( char *newname);
+
 /*
  * VFS helper functions..
  */
diff -ur --new-file linux-2.2.15-pre13.virgin/include/linux/miscdevice.h linux/include/linux/miscdevice.h
--- linux-2.2.15-pre13.virgin/include/linux/miscdevice.h	Mon Aug  9 13:04:41 1999
+++ linux/include/linux/miscdevice.h	Tue Mar  7 22:24:50 2000
@@ -11,6 +11,9 @@
 #define APOLLO_MOUSE_MINOR 7
 #define PC110PAD_MINOR 9
 #define MAC_MOUSE_MINOR 10
+#define DEVPS_MINOR		21
+#define DEVMTAB_MINOR		22
+#define DEVMODULES_MINOR	23
 #define WATCHDOG_MINOR		130	/* Watchdog timer     */
 #define TEMP_MINOR		131	/* Temperature Sensor */
 #define RTC_MINOR 135
diff -ur --new-file linux-2.2.15-pre13.virgin/include/linux/module.h linux/include/linux/module.h
--- linux-2.2.15-pre13.virgin/include/linux/module.h	Tue Mar  7 19:47:04 2000
+++ linux/include/linux/module.h	Tue Mar  7 21:26:48 2000
@@ -8,6 +8,7 @@
 #define _LINUX_MODULE_H
 
 #include <linux/config.h>
+#include <linux/types.h>
 
 #ifdef __GENKSYMS__
 #  define _set_ver(sym) sym
@@ -143,6 +144,21 @@
 
 /* Find a symbol exported by the kernel or another module */
 extern unsigned long get_module_symbol(char *, char *);
+/* Used by /proc and devmodules to export kernel symbols */
+extern int get_ksyms_list(char *buf, char **start, off_t offset, int length);
+/* Used by /proc and devmodules to export the list of modules 
+ * in human readable form */
+extern int get_module_list(char *);
+#if defined CONFIG_DEVMODULES || defined CONFIG_DEVMODULES_MODULE
+#include <linux/devmodules.h>
+/* Used by devmodules to export the list of modules 
+ * in machine readable form */
+extern void get_kmodule_list( int count, struct k_module_item* modlst);
+/* Used by devmodules to export the number of modules */
+extern int count_kmodules(void);
+#endif
+
+
 
 #if defined(MODULE) && !defined(__GENKSYMS__)
 
diff -ur --new-file linux-2.2.15-pre13.virgin/kernel/Makefile linux/kernel/Makefile
--- linux-2.2.15-pre13.virgin/kernel/Makefile	Wed May  6 12:01:46 1998
+++ linux/kernel/Makefile	Tue Mar  7 22:47:07 2000
@@ -11,11 +11,11 @@
 	$(CPP) -traditional $< -o $*.s
 
 O_TARGET := kernel.o
-O_OBJS    = sched.o dma.o fork.o exec_domain.o panic.o printk.o sys.o \
-	    module.o exit.o itimer.o info.o time.o softirq.o resource.o \
+O_OBJS    = sched.o dma.o exec_domain.o panic.o printk.o sys.o \
+	    exit.o itimer.o info.o time.o softirq.o resource.o \
 	    sysctl.o acct.o capability.o
 
-OX_OBJS  += signal.o
+OX_OBJS  += fork.o module.o signal.o
 
 ifeq ($(CONFIG_KMOD),y)
 O_OBJS += kmod.o
diff -ur --new-file linux-2.2.15-pre13.virgin/kernel/fork.c linux/kernel/fork.c
--- linux-2.2.15-pre13.virgin/kernel/fork.c	Tue Oct 26 18:53:42 1999
+++ linux/kernel/fork.c	Tue Mar  7 19:52:45 2000
@@ -36,6 +36,7 @@
 kmem_cache_t *files_cachep; 
 
 struct task_struct *pidhash[PIDHASH_SZ];
+EXPORT_SYMBOL(pidhash);
 
 struct task_struct **tarray_freelist = NULL;
 spinlock_t taskslot_lock = SPIN_LOCK_UNLOCKED;
diff -ur --new-file linux-2.2.15-pre13.virgin/kernel/module.c linux/kernel/module.c
--- linux-2.2.15-pre13.virgin/kernel/module.c	Tue Mar  7 19:47:05 2000
+++ linux/kernel/module.c	Tue Mar  7 22:42:58 2000
@@ -816,10 +816,40 @@
 	module_unmap(mod);
 }
 
+/* Used by devmodules to export the number of modules */
+extern int 
+count_kmodules(void)
+{
+	int i=0;
+	struct module *mod;
+	for (mod = module_list; mod != &kernel_module; mod = mod->next, i++);
+	return i;
+}
+EXPORT_SYMBOL(count_kmodules);
+
+extern void 
+get_kmodule_list( int count, struct k_module_item* modlst)
+{
+	int i = 0;
+	struct module *mod = module_list;
+
+	while (mod && i < count)
+	{
+		strncpy(modlst[i].name, mod->name, 
+				sizeof(modlst[i].name));
+		modlst[i].size = mod->size;
+		modlst[i].flags = mod->flags;
+		modlst[i].usecount = (long)atomic_read(&mod->uc.usecount);
+		mod = mod->next;
+		i++;
+	}
+}
+EXPORT_SYMBOL(get_kmodule_list);
+
+
 /*
  * Called by the /proc file system to return a current list of modules.
  */
-
 int get_module_list(char *p)
 {
 	size_t left = PAGE_SIZE;
@@ -897,11 +927,11 @@
 fini:
 	return PAGE_SIZE - left;
 }
+EXPORT_SYMBOL(get_module_list);
 
 /*
  * Called by the /proc file system to return a current list of ksyms.
  */
-
 int
 get_ksyms_list(char *buf, char **start, off_t offset, int length)
 {
